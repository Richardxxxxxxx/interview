calculate # of 1s: x = x&(x-1)

swap value(say A and B): X = X^(A^B)

sum without addition:
public int getSum(int a, int b) {
    return b == 0 ? a : getSum(a^b, (a&b)<<1);
}

前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

前+中可以唯一确定一颗树。


A Linear Time Majority Vote Algorithm:http://www.cs.utexas.edu/~moore/best-ideas/mjrty/

Floyd's cycle detection:https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare
