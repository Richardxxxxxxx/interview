OS:
https://blog.csdn.net/youngchang06hpu/article/details/8009947
死锁 必要 条件：互斥，不可抢占，占有并等待，环形等待。（必要，破坏任何一个就不会产生死锁）
死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略。
进程 同步 原则：
（1）空闲让进；
（2）忙则等待（保证对临界区的互斥访问）；
（3）有限等待（有限代表有限的时间，避免死等）；
（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。
进程 通信 方式：共享存储器同（say 剪贴板），消息传递，管道。
线程 同步 方式：临界区（仅同进程中的不同线程），事件对象，互斥量，信号量（后三可不同进程间的线程通信）。
线程  与  进程：
（1）进程为系统资源分配和调度的基本单位。
（2）线程为CPU调度和分派的基本单位，每个线程有自己的堆栈，与同属一个进程的其他的线程共享进程所拥有的全部资源，一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行
临界区 策略：
（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；
（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；
（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；
（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。
缓冲区溢出：缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。
network:

database:
https://blog.csdn.net/hectorhua/article/details/13767361
python:
http://python.jobbole.com/85231/

C++:
构造函数：
赋值：https://blog.csdn.net/chenlycly/article/details/53558675
初始化顺序：https://blog.csdn.net/real_myth/article/details/51752212
初始化列表：https://www.cnblogs.com/BlueTzar/articles/1223169.html
多态：
https://blog.csdn.net/wendy_keeping/article/details/75213671
https://www.cnblogs.com/AndyJee/p/4578586.html
https://blog.csdn.net/stpeace/article/details/77799724
（多态赋值实际上只是赋值了一个虚表于0位置，根据声明类型中的函数类型,续函数查找虚表，别的函数于编译器已静态绑定，及时在指向类中被重定义也不受影响）
重载，重写，重定义：
重载：相同作用域、函数名，参数列表不同，返回值同不同都行（仅仅返回值不同而参数列表相同，无法区分函数，进行重载，是不是虚函数无所谓）
重写：不同作用域，基类函数必须是虚函数，函数名、参数列表和返回类型必须相同
重定义：不同作用域，函数名相同，返回值可以不同，
（1）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。
（2）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。
https://www.cnblogs.com/feiguo/archive/2013/11/29/3449352.html
https://blog.csdn.net/gogogo_sky/article/details/72860426
const:
 int b = 500;
       const int* a = &b;               [1]  *a不能更改
       int const *a = &b;               [2]  *a不能更改
       int* const a = &b;               [3]  a不能更改
       const int* const a = &b;         [4]  *a & a 不能更改
       void fun0(const A* a );          [5]  a 不能更改（指向地址）
       void fun1(const A& a);           [6]  a 不能更改（对象属性）
       const A fun2( );                 [7]  返回值A不能修改（对象属性）
       const A* fun3( );                [8]  返回值A不能修改（指向地址）
       void fun() const;                [9]  禁止修改数据成员
hreference: https://blog.csdn.net/arduousbonze/article/details/1609833


differences between new/delete and malloc/free, core idea: new/delete pair is an operator, it will invoke construct/deconstruct when called
reference:https://blog.csdn.net/qq_26816591/article/details/52214313

linux:
JAVA:
